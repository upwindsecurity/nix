{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.upwindAgent;
  upwindAgentPkg = pkgs.callPackage ./default.nix { # Fixed path to default.nix
    # Pass required versions/hashes here, perhaps fetched separately or defined in options
    upwindAgentVersion = cfg.package.overrideVersion or "0.111.0";
    upwindAgentSha256_amd64 = "m0MGVhIOs+UGtNquGpxO1DTJeGlGaE1eUTTS3YAXaiA=";
    upwindAgentSha256_arm64 = "18fK9JJlHR9QJoaqnl0/42tWrhznQ9VBE0U54/dcudA=";
    hostconfigVersion = cfg.hostconfigPackage.overrideVersion or "0.5.2";
    hostconfigSha256_amd64 = "18fK9JJlHR9QJoaqnl0/42tWrhznQ9VBE0U54/dcudA=";
    hostconfigSha256_arm64 = "z6kJOcEmxLJEm+/ZBb3jF1G1WdGf8aLoJ22fIrqVSsI=";
  };
in
{
  options.services.upwindAgent = {
    enable = mkEnableOption "Upwind Security Agent";

    package = mkOption {
      type = types.package;
      default = upwindAgentPkg;
      description = "The Upwind Agent package to use.";
    };

    hostconfigPackage = mkOption {
       # Similar option for hostconfig if needed separately
       type = types.package;
       default = upwindAgentPkg; # Assuming same package provides both for simplicity
       description = "The Upwind Agent Hostconfig package to use.";
    };

    region = mkOption {
      type = types.enum [ "us" "eu" ];
      default = "us";
      description = "Upwind region.";
    };

    clientIdFile = mkOption {
      type = types.path;
      description = "Path to file containing the Upwind API Client ID.";
      # Example: default = "/run/secrets/upwind-client-id";
    };

    clientSecretFile = mkOption {
      type = types.path;
      description = "Path to file containing the Upwind API Client Secret.";
      # Example: default = "/run/secrets/upwind-client-secret";
    };

    logLevel = mkOption {
      type = types.str;
      default = "info";
      description = "Log level for the agent.";
    };

    # CPU and memory resource limits
    cpuQuota = mkOption {
      type = types.nullOr types.str; # e.g., "50%"
      default = null; # Use systemd default or agent default if null
      description = "Systemd CPUQuota setting for the agent service.";
    };

    memoryMax = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "Maximum memory limit for the agent service (e.g., '1G').";
    };

    memoryHigh = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "Memory threshold for the agent service when throttling begins.";
    };

    containerized = mkOption {
      type = types.bool;
      default = false; # Match script default
      description = "Whether to run the agent as a container (requires docker/podman setup).";
    };

    # Scanner resource settings
    scannerCpuWeight = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = "CPU weight for the scanner service.";
    };

    scannerIoWeight = mkOption {
      type = types.nullOr types.int;
      default = null;
      description = "I/O weight for the scanner service.";
    };

    scannerMemoryMax = mkOption {
      type = types.nullOr types.str;
      default = null;
      description = "Maximum memory limit for the scanner service (e.g., '500M').";
    };

    # ... add options corresponding to UPWIND_ variables
  };

  config = mkIf cfg.enable {
    # Configuration File Generation
    environment.etc."upwind/agent.yaml".text = ''
      # Upwind Sensor Configuration generated by NixOS
      region: "${cfg.region}"
      api-host: "https://agent${if cfg.region == "eu" then ".eu" else ""}.upwind.io" # Derived from script logic
      auth-endpoint: "https://oauth${if cfg.region == "eu" then ".eu" else ""}.upwind.io/oauth/token" # Derived
      auth-client-id: ${readFile cfg.clientIdFile} # Read from secret file
      auth-client-secret: ${readFile cfg.clientSecretFile} # Read from secret file
      log-level: "${cfg.logLevel}"
      # ... other config keys based on options and script logic
      install-type: ${if cfg.containerized then "\"bcc\"" else "\"std\""} # Example logic based on containerized flag
      cluster-agent-domain: "192.168.50.224"
      cluster-agent-protocol-version: "6"
      platform: "host"
      # ... add features like sock-perf, proc-username
    '';

    environment.etc."upwind/agent-hostconfig.yaml".text = ''
      # Upwind Hostconfig Configuration generated by NixOS
      region: "${cfg.region}"
      api-host: "https://agent${if cfg.region == "eu" then ".eu" else ""}.upwind.io"
      auth-endpoint: "https://oauth${if cfg.region == "eu" then ".eu" else ""}.upwind.io/oauth/token"
      log-level: "${cfg.logLevel}" # Assuming same log level option
      # ... other hostconfig specific settings
    '';

    # Environment file for secrets (Alternative to embedding in YAML)
    # Could be used if agent reads ENV vars instead of file creds
    # environment.etc."upwind/agent.env".text = ''
    #   UPWIND_CLIENT_ID=${readFile cfg.clientIdFile}
    #   UPWIND_CLIENT_SECRET=${readFile cfg.clientSecretFile}
    # '';

    # Systemd Service Definition
    systemd.services.upwind-agent = {
      description = "Upwind Sensor";
      after = [ "network-online.target" ];
      wants = [ "network-online.target" ];
      wantedBy = [ "multi-user.target" ];

      serviceConfig = {
        ExecStart = "${cfg.package}/bin/upwind-agent agent";
        Restart = "always";
        # EnvironmentFile = "/etc/upwind/agent.env"; # If using env file
        # Resource Controls - map options to systemd properties
        CPUQuota = cfg.cpuQuota;
        MemoryMax = cfg.memoryMax; # Define memoryMax option
        MemoryHigh = cfg.memoryHigh; # Define memoryHigh option
        # ... other service settings
      };
      # Required for secrets access if using file paths like /run/secrets
      # Requires systemd v243+
      # LoadCredential = [
      #   "upwind-client-id:${cfg.clientIdFile}"
      #   "upwind-client-secret:${cfg.clientSecretFile}"
      # ];
    };

    # Hostconfig Service
    systemd.services.upwind-agent-hostconfig = {
      description = "Upwind Sensor Hostconfig";
      after = [ "network-online.target" ];
      wants = [ "network-online.target" ];
      wantedBy = [ "multi-user.target" ];
      serviceConfig = {
        ExecStart = "${cfg.hostconfigPackage}/bin/upwind-agent-hostconfig";
        Restart = "always";
        # EnvironmentFile = "/etc/upwind/agent.env";
      };
    };

    # Scanner Service (example - type=oneshot)
    systemd.services.upwind-agent-scanner = {
      description = "Upwind Sensor Scanner";
      serviceConfig = {
        Type = "oneshot";
        ExecStart = "${cfg.package}/bin/upwind-agent scan --path=/"; # Assuming scan command
        # Resource controls for scanner
        CPUWeight = cfg.scannerCpuWeight; # Define option
        IOWeight = cfg.scannerIoWeight;   # Define option
        MemoryMax = cfg.scannerMemoryMax; # Define option
        # ...
      };
    };

    # Scanner Timer
    systemd.timers.upwind-agent-scanner = {
       description = "Upwind Sensor Scanner Timer";
       wantedBy = [ "timers.target" ];
       timerConfig = {
         OnCalendar = "*:00:00"; # From script
         AccuracySec = "5m";   # From script
         Unit = "upwind-agent-scanner.service";
       };
    };

    # Update Service/Timer - Generally not used in NixOS, updates handled by `nixos-rebuild switch --upgrade`
    # If absolutely needed, you could replicate it, but it's against Nix philosophy.

    # Containerized Mode Handling (More Complex)
    # If cfg.containerized is true, you would:
    # 1. Fetch the container image using pkgs.dockerTools.pullImage instead of fetchurl.
    # 2. Define the service using NixOS container tools (e.g., virtualisation.oci-containers.containers.<name>...)
    #    or by setting ExecStart to use `docker run` or `podman run`, translating the script's complex run command.
    #    This requires the docker/podman daemon to be running and configured.
  };
}
